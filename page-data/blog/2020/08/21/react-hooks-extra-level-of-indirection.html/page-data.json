{"componentChunkName":"component---src-templates-blog-js","path":"/blog/2020/08/21/react-hooks-extra-level-of-indirection.html","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>本文由百度资深研发工程师兼百度 ECOMFE FE-CMC 现任主席 — 张立理大佬授权转载。本系列文章对 Hook 进行了深度剖析。</p>\n</blockquote>\n<p>React Hooks 是 React 框架内的逻辑复用形式，因其轻量、易编写的形态，必然会逐渐成为一种主流。但在实际的开发中，我依然觉得大部分的开发者对 hook 的使用过于粗暴，缺乏设计感和复用性。</p>\n<p>我在<a href=\"https://www.zhihu.com/question/357020049/answer/909484669\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">《如何去合理使用 React hook》的回答</a>中有简单地提到一些思路，之后我会发布一个小系列来展开地讲述 hook 的设计和实现细节问题。</p>\n<h2 id=\"万物始于分层\"><a href=\"#%E4%B8%87%E7%89%A9%E5%A7%8B%E4%BA%8E%E5%88%86%E5%B1%82\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>万物始于分层</h2>\n<p>软件工程中的经典论述：</p>\n<blockquote>\n<p>We can solve any problem by introducing an extra level of indirection.</p>\n<p>没有什么问题是加一个层解决不了的。</p>\n</blockquote>\n<p>这个论述自软件工程诞生起，时至今日依然是成立的。但要使之成立就必须有一个大前提：我们有分层。</p>\n<p>React 内置的 hook 提供了基础的能力，虽然本质上它也有一些分层，比如：</p>\n<ul>\n<li><code class=\"gatsby-code-text\">useState</code> 是基于 <code class=\"gatsby-code-text\">useReducer</code> 的简化版。</li>\n<li><code class=\"gatsby-code-text\">useMemo</code> 和 <code class=\"gatsby-code-text\">useCallback</code> 事实上可以基于 <code class=\"gatsby-code-text\">useRef</code> 实现。</li>\n</ul>\n<p>但在实际应用时，我们可以将这些统一视为一层，即最基础的底层。</p>\n<p>因此，如果我们在实际的应用开发中，单纯地在组件里组合使用内置的 hook，无疑是一种不分层的粗暴使用形式，这仅仅在表象上使用了 hook，而无法基于 hook 达到逻辑复用的目标。</p>\n<h2 id=\"状态的分层设计\"><a href=\"#%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>状态的分层设计</h2>\n<p>分层的形式固然千千万万五花八门，我选择了一种更为贴近传统、更能表达程序的本质的方法，以此将 hook 在纵向分为了 6 个层，自底向上依次是：</p>\n<ol>\n<li>最底层的内置 hook，不需要自己实现，官方直接提供。</li>\n<li>简化状态更新方式的 hook，比较经典的是引入 <a href=\"https://github.com/immerjs/immer\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">immer</a> 来达到更方便地进行不可变更新的目的。</li>\n<li>引入“状态 + 行为”的概念，通过声明状态结构与相应行为快速创建一个完整上下文。</li>\n<li>对常见数据结构的操作进行封装，如数组的操作。</li>\n<li>针对通用业务场景进行封装，如分页的列表、滚动加载的列表、多选等。</li>\n<li>实际面向业务的实现。</li>\n</ol>\n<p>需要注意的是，这边仅提到了对状态的分层设计。事实上有大量的 hook 是游离于状态之外的，如基于 <code class=\"gatsby-code-text\">useEffect</code> 的 <code class=\"gatsby-code-text\">useDocumentTitle</code>、<code class=\"gatsby-code-text\">useElementSize</code>，或基于 <code class=\"gatsby-code-text\">useRef</code> 的 <code class=\"gatsby-code-text\">usePreviousValue</code>、<code class=\"gatsby-code-text\">useStableMemo</code> 等，这些 hook 是更加零散、独立的形态。</p>\n<h3 id=\"使用-immer-更新状态\"><a href=\"#%E4%BD%BF%E7%94%A8-immer-%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>使用 immer 更新状态</h3>\n<p>在第二层中，我们需要解决的问题是 React 要求的不可变数据更新有一定的操作复杂性，比如当我们需要更新对象的一个属性时，就需要：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">const</span> newValue <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>oldValue<span class=\"token punctuation\">,</span>\n    foo<span class=\"token operator\">:</span> newFoo<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这仅限于一个属性的更新，如果属性的层级较深时，代码就不得不变成这样子：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">const</span> newValue <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>oldValue<span class=\"token punctuation\">,</span>\n    foo<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token operator\">...</span>oldValue<span class=\"token operator\">?.</span>foo<span class=\"token punctuation\">,</span>\n        bar<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token operator\">...</span>oldValue<span class=\"token operator\">?.</span>foo<span class=\"token operator\">?.</span>bar<span class=\"token punctuation\">,</span>\n            alice<span class=\"token operator\">:</span> newAlice\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>数组同样也不怎么容易，比如想删除一个元素，你就得这么来：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">const</span> newArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token operator\">...</span>oldArray<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token operator\">...</span>oldArray<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>要解决这一系列的问题，我们可以使用 immer 进行更新，利用 <code class=\"gatsby-code-text\">Proxy</code> 的特性将可变的数据更新映射为不可变的操作。</p>\n<p>状态管理的基础 hook 是 <code class=\"gatsby-code-text\">useState</code> 和 <code class=\"gatsby-code-text\">useReducer</code>，因此我们能封装成：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>state<span class=\"token punctuation\">,</span> setState<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useImmerState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>foo<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>bar<span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">s</span> <span class=\"token operator\">=></span> s<span class=\"token punctuation\">.</span>foo<span class=\"token punctuation\">.</span>bar<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 直接进行可变更新</span>\n<span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>foo<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>bar<span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 保留直接更新值的功能</span></code></pre></div>\n<p>以及：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>state<span class=\"token punctuation\">,</span> dispatch<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useImmerReducer</span><span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span><span class=\"token parameter\">state<span class=\"token punctuation\">,</span> action</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">case</span> <span class=\"token string\">'ADD'</span><span class=\"token operator\">:</span>\n            state<span class=\"token punctuation\">.</span>foo<span class=\"token punctuation\">.</span>bar <span class=\"token operator\">+=</span> action<span class=\"token punctuation\">.</span>payload<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> <span class=\"token string\">'SUBTRACT'</span><span class=\"token operator\">:</span>\n            state<span class=\"token punctuation\">.</span>foo<span class=\"token punctuation\">.</span>bar <span class=\"token operator\">-=</span> action<span class=\"token punctuation\">.</span>payload<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>foo<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>bar<span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ADD'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>payload<span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这一部分并没有太多的工作 (immer 的 TS 类型是真的难写)，但提供了非常方便的状态更新能力，也便于在它之上的所有层的实现。</p>\n<h3 id=\"状态与行为的封装\"><a href=\"#%E7%8A%B6%E6%80%81%E4%B8%8E%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%B0%81%E8%A3%85\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>状态与行为的封装</h3>\n<p>组件的开发，或者说绝大部分的业务的开发，逃不出“一个状态加一系列行为”这个模式，且行为与状态的结构是强相关的。这个模式在面向对象里我们称之为类：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n    name <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n    age <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">birthday</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>而在 hook 中，我们会这么来：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">,</span> setName<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>age<span class=\"token punctuation\">,</span> SetAge<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> birthday <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">age</span> <span class=\"token operator\">=></span> age <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">[</span>age<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>会出现一些问题：</p>\n<ol>\n<li>太多的 <code class=\"gatsby-code-text\">useState</code> 和 <code class=\"gatsby-code-text\">useCallback</code> 调用，重复的编码工作。</li>\n<li>如果不仔细阅读代码，很难找到状态与行为的对应关系。</li>\n</ol>\n<p>因此，我们需要一个 hook 能帮我们把“一个状态”和“针对这个状态的行为”合并在一起：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">const</span> userMethods <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">birthday</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">user</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        user<span class=\"token punctuation\">.</span>age<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 利用了immer的能力</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>user<span class=\"token punctuation\">,</span> methods<span class=\"token punctuation\">,</span> setUser<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useMethods</span><span class=\"token punctuation\">(</span>\n    userMethods<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>name<span class=\"token operator\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span> age<span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nmethods<span class=\"token punctuation\">.</span><span class=\"token function\">birthday</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>可以看到，这样的声明非常接近面向对象的形态。有部分 React 的开发者在粗浅地了解函数式编程后，成了激进的“反面向对象党”，这显然是不可取的，面向对象依然是一种很好的封装和职责边界划分的形态，不一定要以其表面形态去实现，却也万万不可丢弃了其内在理念。</p>\n<h3 id=\"数据结构的抽象\"><a href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%8A%BD%E8%B1%A1\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>数据结构的抽象</h3>\n<p>有了 <code class=\"gatsby-code-text\">useMethods</code> 之后，我们已经可以快速地使任何类型和结构的状态与 hook 整合。我们一定会意识到，有一部分状态类型是业务无关的，是全天下开发者公用的，比如最基础的数据类型 <code class=\"gatsby-code-text\">number</code>、<code class=\"gatsby-code-text\">string</code>、<code class=\"gatsby-code-text\">Array</code> 等。</p>\n<p>在数据类型的封装上，我们依然会面对几个核心问题：</p>\n<ol>\n<li>部分数据类型的不可变操作相当复杂，比如不可变地实现 <code class=\"gatsby-code-text\">Array#splice</code>，好在有 immer 合理地解决了问题。</li>\n<li>部分操作的语义会发生变化，<code class=\"gatsby-code-text\">setState</code> 最典型的是没有返回值，因此 <code class=\"gatsby-code-text\">Array#pop</code> 只能产生“移除最后一个元素”的行为，而无法将移除的元素返回。</li>\n<li>部分类型是天生可变的，如 <code class=\"gatsby-code-text\">Set</code> 和 <code class=\"gatsby-code-text\">Map</code>，将之映射到不可变需要额外的工作。</li>\n</ol>\n<p>针对常用数据结构的抽象，在试图解决这些问题 (第 2 个问题还真解决不了) 的同时，也能扩展一些行为，比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"gatsby-code-ts\"><code class=\"gatsby-code-ts\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>list<span class=\"token punctuation\">,</span> methods<span class=\"token punctuation\">,</span> setList<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">ArrayMethods<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">push</span><span class=\"token punctuation\">(</span>item<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">unshift</span><span class=\"token punctuation\">(</span>item<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>start<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> count<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>items<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>item<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">removeAt</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">insertAt</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> item<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>item<span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token operator\">|</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">from</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> to<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">replaceAll</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">from</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> to<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">replaceAt</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> item<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">predicate</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>item<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> index<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">union</span><span class=\"token punctuation\">(</span>array<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">intersect</span><span class=\"token punctuation\">(</span>array<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">difference</span><span class=\"token punctuation\">(</span>array<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>compare<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>而诸如 <code class=\"gatsby-code-text\">useSet</code> 和 <code class=\"gatsby-code-text\">useMap</code> 则会在每次更新时做一次对象复制的操作，强制实现状态的不可变。</p>\n<p>我在社区的 hook 库中，很少看到有单独一个层实现数据结构的封装，实为一种遗憾。截止到今日，大致 <code class=\"gatsby-code-text\">useNumber</code>、<code class=\"gatsby-code-text\">useArray</code>、<code class=\"gatsby-code-text\">useSet</code>、<code class=\"gatsby-code-text\">useMap</code>、<code class=\"gatsby-code-text\">useBoolean</code> 是已然实现的，其中还衍生出 <code class=\"gatsby-code-text\">useToggle</code> 这样场景更狭窄的实现。而 <code class=\"gatsby-code-text\">useString</code>、<code class=\"gatsby-code-text\">useFunction</code> 和 <code class=\"gatsby-code-text\">useObject</code> 能够提供什么能力还有待观察。</p>\n<h3 id=\"通用场景封装\"><a href=\"#%E9%80%9A%E7%94%A8%E5%9C%BA%E6%99%AF%E5%B0%81%E8%A3%85\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>通用场景封装</h3>\n<p>在有了基本的数据结构后，可以对场景进行封装，这一点在阿里的 <a href=\"https://github.com/umijs/hooks\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">@umijs/hooks</a> 体现的比较多，如 <code class=\"gatsby-code-text\">useVirtualList</code> 就是一个价值非常大的场景的封装。</p>\n<p>需要注意的是，场景的封装不应与组件库耦合，它应当是业务与组件之间的桥梁，不同的组件库使用相同的 hook 实现不同的界面，这才是一个理想的模式：</p>\n<ul>\n<li><code class=\"gatsby-code-text\">useTransfer</code> 实现左右双列表选择的能力。</li>\n<li><code class=\"gatsby-code-text\">useSelection</code> 实现列表上单选、多选、范围选择的能力</li>\n<li><code class=\"gatsby-code-text\">useScrollToLoad</code> 实现滚动加载的能力。</li>\n</ul>\n<p>通用场景的封装非常的多，它的灵感可以来源于某一个组件库，也可以由团队的业务沉淀。一个充分的场景封装 hook 集合会是未来 React 业务开发的效率的关键之一。</p>\n<h2 id=\"总结\"><a href=\"#%E6%80%BB%E7%BB%93\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>总结</h2>\n<p>总而言之，在业务中暴力地直接使用 <code class=\"gatsby-code-text\">useState</code> 等 hook 并不是一个值得提倡的方式，而针对状态这一块，精细地做一下分层，并在每个层提供相应的能力，是有助于组织 hook 库并赋能于业务研发效率的。</p>\n<p>我们正在研发一个命名为 <a href=\"https://github.com/ecomfe/react-hooks\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">@huse</a> 的 hook 集合，同样应用了分层的理念，也欢迎提出相应的需求，将于近期发布一个版本。</p>","excerpt":"本文由百度资深研发工程师兼百度 ECOMFE FE-CMC 现任主席 — 张立理大佬授权转载。本系列文章对 Hook 进行了深度剖析。 React Hooks 是 React 框架内的逻辑复用形式，因其轻量、易编写的形态，必然会逐渐成为一种主流。但在实际的开发中，我依然觉得大部分的开发者对 hook 的使用过于粗暴，缺乏设计感和复用性。 我在《如何去合理使用 React hook》的回答中有简单地提到一些思路，之后我会发布一个小系列来展开地讲述 hook 的设计和实现细节问题。 万物始于分层 软件工程中的经典论述： We can solve any problem by introducing an extra level of indirection. 没有什么问题是加一个层解决不了的。 这个论述自软件工程诞生起，时至今日依然是成立的。但要使之成立就必须有一个大前提：我们有分层。 React 内置的 hook…","frontmatter":{"title":"React Hooks 的体系设计之一 - 分层","next":null,"prev":null,"author":[]},"fields":{"date":"August 21, 2020","path":"content/blog/2020-08-21-react-hooks-extra-level-of-indirection.md","slug":"/blog/2020/08/21/react-hooks-extra-level-of-indirection.html"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"title":"React Hooks 的体系设计之一 - 分层"},"fields":{"slug":"/blog/2020/08/21/react-hooks-extra-level-of-indirection.html"}}},{"node":{"frontmatter":{"title":"React v17.0 RC 版本发布：没有新特性"},"fields":{"slug":"/blog/2020/08/10/react-v17-rc.html"}}},{"node":{"frontmatter":{"title":"React Hook 最佳实践"},"fields":{"slug":"/blog/2020/05/22/react-hooks.html"}}},{"node":{"frontmatter":{"title":"React v16.13.0"},"fields":{"slug":"/blog/2020/02/26/react-v16.13.0.html"}}},{"node":{"frontmatter":{"title":"Building Great User Experiences with Concurrent Mode and Suspense"},"fields":{"slug":"/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html"}}},{"node":{"frontmatter":{"title":"使用 React 预发布版为新功能打基础"},"fields":{"slug":"/blog/2019/10/22/react-release-channels.html"}}},{"node":{"frontmatter":{"title":"全新的 React DevTools 简介"},"fields":{"slug":"/blog/2019/08/15/new-react-devtools.html"}}},{"node":{"frontmatter":{"title":"React v16.9.0 发布及 Roadmap 最新进展"},"fields":{"slug":"/blog/2019/08/08/react-v16.9.0.html"}}},{"node":{"frontmatter":{"title":"Is React Translated Yet? ¡Sí! Sim! はい！"},"fields":{"slug":"/blog/2019/02/23/is-react-translated-yet.html"}}},{"node":{"frontmatter":{"title":"React v16.8：Hook 发布"},"fields":{"slug":"/blog/2019/02/06/react-v16.8.0.html"}}}]}},"pageContext":{"slug":"/blog/2020/08/21/react-hooks-extra-level-of-indirection.html"}},"staticQueryHashes":[]}